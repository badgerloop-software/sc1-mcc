#!/bin/bash
VERSION=mbed-os-6.15.1-latest
MBED_OS_IMAGE=ghcr.io/armmbed/mbed-os-env:${VERSION}
CONTAINER_HOSTNAME=bloop-dev
PROD_IMAGE_NAME=bloop-mbed
DEV_IMAGE_NAME=bloop-dev-$(git rev-parse --short=7 HEAD)
DOCKER_BUILD_ARGS="--build-arg UID=$(id -u) --build-arg GID=$(id -g)"
REGISTRY_DOMAIN=ghcr.io
REGISTRY_ORG=badgerloop-software
UPSTREAM_IMAGE=${REGISTRY_DOMAIN}/${REGISTRY_ORG}/${PROD_IMAGE_NAME}:latest
TARGET_IMAGE=${UPSTREAM_IMAGE} # Default - may change below

# HW Stuff
NUCLEO_MOUNTPOINT=/mnt/nucleo

# Help with clean prints
alias echo='{ set +x; } 2> /dev/null; builtin echo'

function build_image {
    if [[ $# -ge 1  && $1 == "prod" ]]; then
        echo "Building PROD scoped image"
        BUILD_NAME=${REGISTRY_DOMAIN}/${REGISTRY_ORG}/${PROD_IMAGE_NAME}
    else
        echo "Building dev scoped image"
        BUILD_NAME=${DEV_IMAGE_NAME}
    fi
    docker build -t ${BUILD_NAME} ${DOCKER_BUILD_ARGS} .
}

dev_image_exists()
{
    docker image inspect ${DEV_IMAGE_NAME} > /dev/null
    builtin echo $?
}

function mount_nucleo {
    echo "Mounting Nucleo"
    echo "Requiring sudo access... enter sudo password"
    sudo mkdir ${NUCLEO_MOUNTPOINT}
}

die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dvibph'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_device_mount="off"
_arg_verbose="off"
_arg_development_image="off"
_arg_build="off"
_arg_publish="off"


print_help()
{
	printf '%s\n' "Bloop-dev: MBed Development done easy"
	printf 'Usage: %s [-d|--(no-)device-mount] [-v|--(no-)verbose] [-i|--(no-)development-image] [-b|--(no-)build] [-p|--(no-)publish] [-h|--help]\n' "$0"
	printf '\t%s\n' "-d, --device-mount, --no-device-mount: Mount a device (off by default)"
	printf '\t%s\n' "-v, --verbose, --no-verbose: Verbose mode (helpful for debugging (off by default)"
	printf '\t%s\n' "-i, --development-image, --no-development-image: Run local development image (off by default)"
	printf '\t%s\n' "-b, --build, --no-build: Build local development image (off by default)"
	printf '\t%s\n' "-p, --publish, --no-publish: Publish local docker image to remote (admin credentials required) (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--no-device-mount|--device-mount)
				_arg_device_mount="on"
				test "${1:0:5}" = "--no-" && _arg_device_mount="off"
				;;
			-d*)
				_arg_device_mount="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-i|--no-development-image|--development-image)
				_arg_development_image="on"
				test "${1:0:5}" = "--no-" && _arg_development_image="off"
				;;
			-i*)
				_arg_development_image="on"
				_next="${_key##-i}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-i" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-b|--no-build|--build)
				_arg_build="on"
				test "${1:0:5}" = "--no-" && _arg_build="off"
				;;
			-b*)
				_arg_build="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-p|--no-publish|--publish)
				_arg_publish="on"
				test "${1:0:5}" = "--no-" && _arg_publish="off"
				;;
			-p*)
				_arg_publish="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

echo "  ____  _                     _____             "
echo " |  _ \| |                   |  __ \            "
echo " | |_) | | ___   ___  _ __   | |  | | _____   __"
echo " |  _ <| |/ _ \ / _ \| '_ \  | |  | |/ _ \ \ / /"
echo " | |_) | | (_) | (_) | |_) | | |__| |  __/\ V / "
echo " |____/|_|\___/ \___/| .__/  |_____/ \___| \_/  "
echo "                     | |                        "
echo "                     |_|                        "
echo "Run $0 -h to print help"

if [ ${_arg_verbose} == "off" ]; then
	set +x
fi

if [[ -z $(command -v docker) ]]; then
    echo "======================================================================"
    echo "ERROR: Docker not installed"
    echo "Install Docker first"
    echo "WSL: https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers"
    echo "Linux: https://docs.docker.com/engine/install/ubuntu/"
    echo "Mac: https://docs.docker.com/desktop/install/mac-install/"
    echo "======================================================================"
    exit 1
fi


if [ ${_arg_device_mount} == "on" ]; then
	# Mount the device here
	echo "Mounting device"
	if [ ! -d ${NUCLEO_MOUNTPOINT} ]; then
		echo "Nucleo not mounted"
	fi
fi

if [ ${_arg_build} == "on" ]; then
	build_image
	if [ ${_arg_development_image} == "off" ]; then
		echo "Image setup sucessfully, run \"$0 dev\" to build local image"
		exit 0
	fi
fi

if [ ${_arg_development_image} == "on" ]; then
    if [[ dev_image_exists == "1" ]]; then
		echo "====================================================="
		echo "ERROR: Dev image does not exist locally"
		echo "Run $0 setup-dev or $0 dev build to build local image"
		echo "====================================================="
		exit 1
	fi
    TARGET_IMAGE=${DEV_IMAGE_NAME}
fi


if [ ${_arg_publish} == "on" ]; then
    echo "Unless you are an admin with a package write token already registered, this command \
    is not for you..."
    echo "Don't worry, if this was a mistake, nothing bad will happen"
    echo "Simply press ctrl+c to exit the prompt"
    build_image prod
    if ! docker login ghcr.io ; then
        echo "=================================================================================================="
        echo "ERROR: Failed to login to registry"
        echo "Make sure your PAT is correct and authorized by a GitHub admin"
        echo "If you are not a GitHub admin but are supposed to push, contact a GitHub Admin to approve your PAT"
        echo "=================================================================================================="
        exit 1
    fi
    docker push ghcr.io/${REGISTRY_ORG}/${PROD_IMAGE_NAME}:latest
    exit 0
fi

echo "Targeting Image ${TARGET_IMAGE}"

if [[ ${_arg_development_image} == "off" ]]; then
    docker pull ${TARGET_IMAGE}
fi

docker run -it --rm --privileged -v /dev:/dev -v /run/udev:/run/udev:ro -v $(pwd):/src -h ${CONTAINER_HOSTNAME} ${TARGET_IMAGE}

